!! Mapping

How does Pharo knows the source code interval corresponding to an executed bytecode?

!!! What is the bytecode to AST mapping?

When executing code step by step in the debugger, the code going to be executed is highlighted so that we visually see where the execution is currently halted. Each time we step, the highlighted code is executed then the highlighted text is updated accordingly. This visualisation is available in methods and within blocks such as in the example below (Fig. *@selectedCode*).

+Stepping in a block: the next instruction that will execute is highlighted.>file://figures/code-ex.png|width=60|label=selectedCode+

The highlight indexes in the source code are encoded in the AST. Because at run time this is bytecode that is executed, tools need to recover the AST corresponding to the executed bytecode. To that end, those tools (e.g., the debugger) use a mapping that allows for recovering the AST corresponding to a particular bytecode.

But how is the AST recovered from the executed bytecode?

!!!Mapping bytecode to AST: an overview of the mapping process

How generated bytecode is mapped to its corresponding AST is depicted in the overview below. Two mappings are stored by the intermediate representation (IR) of compiled code:

# an IR ==\<\-\>== AST mapping
# an IR ==\-\>== bytecode mapping

The IR ==->== bytecode mapping is a sequence of bytecode corresponding to the IR. For instance for the IR of a method, the sequence is the bytecode of the method.

+Stepping in a block: the next instruction that will execute is highlighted.>file://figures/compilation-chain.png|width=60|label=compilationChain+

Fig *@compilationChain* gives an overview of the mapping process at compile time. The first step is the parsing of the source code, which is transformed into an AST. Then every node of that tree is converted to an intermediate representation (1a). At each IR generation, the source AST from which it was just generated is mapped to that IR (1b). One AST therefore map to one IR and vice versa. Then each IR is converted to bytecode (2a). Similarly to the IR AST mapping, each generated bytecode is mapped by its source IR in an IR -> bytecode mapping stored by the IR (2b).


Fig. *@inspector* shows an inspector opened on the IR of the closeTo: method from Fig. *@selectedCode*. That IR has a source node, which is the AST from which it was created (A). It also has a sequence of IR instructions (B).

+IR Mapping: source AST and IR sequence (instructions).>file://figures/mapping-ex.png|width=60|label=inspector+

Each IR instruction from the IR sequence has a bytecode index (Fig. 4). This index is the index of the last generated bytecode for that IR. Because many bytecode instructions can be generated for an IR instruction, the bytecode index is overwritten for each generated bytecode for that IR. Therefore, an IR instruction only references the index of the last bytecode it generated.


+IR sequence instructions: each IR instruction knows the bytecode index of the last generated bytecode for that IR.>file://figures/ir-ex.png|width=60|label=inspector+


!!! computing offsets


!!! computing offsets with the sistav1 compiler and full block closures

!!! Accessing the mapping at run time

Tools need to know what is the node that corresponds to an executed bytecode.
This is the case for debuggers.

Tools endup calling the method ==sourceNodeForPC:== that is defined as an interface for every compiled code (==CompiledMethod== and ==CompiledBlock==) but that is actually implemented in the AST node representing the compiled code. 
Compiled methods will delegate this behavior to their method node and compiled blocks to their block node. 
In both case, the compiled code has to retrieve that node.

Let us have a look to the implementation in RBMethodNode:

[[[
RBMethodNode>>sourceNodeForPC: anInteger
	^(self ir instructionForPC: anInteger) sourceNode
]]]	
	
The ir is requested to provide the instruction that correspond to the program counter given as parameter. 
The implementation is shown below:

[[[
IRMethod>>instructionForPC: aPC
	| initialPC pc |
	"generates the compiledMethod and optimize the ir.
	Removes the side-effect of optimizing the IR while looking for instruction,
	which results in incorrect found instruction"
	initialPC := self compiledMethod initialPC.
	"For a given PC, the actual instruction may start N bytes ahead."
	pc := aPC.
	[ pc >= initialPC ] whileTrue: [
		(self firstInstructionMatching: [:ir | ir bytecodeOffset = pc ])
				ifNotNil: [:it |^it].
		pc := pc - 1 ].
	^self "if we not found anything then this method is our target instruction"
]]]	
	
Long story short: the instruction corresponding to the given PC is retrieved by enumerating all instructions and returning the first whose bytecode offset equals the PC.

But there are some subtleties.


!!!! The PC can be N bytes ahead of the current instruction (why?)

Because of that, we search the instruction by decrementing the PC. We first enumerate all instructions and look for one with a bytecode offset equal to the PC. If there are none, then we decrement the PC by 1 and search again over all the instructions.

If the decrementd PC ends up being lower than the initialPC, i.e. the bytecode offset of the first instruction of the method, then the instruction corresponding to the method is returned (the IRMethodinstance).

!!!! A method's bytecode offset does not start at 0

A method starts at initialPC, that is never 0. It is computed in the compiled code object associated to the IR requesting the initial PC. As shown below, the value of the first PC of a method is the size in bytes of its literals.

[[[
CompiledCode>>initialPC
	"Answer the program counter for the receiver's first bytecode."

	^ (self numLiterals + 1) * Smalltalk wordSize + 1
]]]

!!!! There are holes in the offsets

Because multiple bytecodes may refer to the same instruction, only the last computed offset is mapped. This means that a mapping can jump, e.g., from 46 to 48 with nothing in between. In the internal representation, offsets 46 and 47 actually correspond to the same instruction (i.e. to the same node), but only 46 is mapped to an instruction.

So, if we request the instruction for a program counter of 47, enumerating all instructions will give no result. Then as explained above, the PC is decremented and a new search is performed for offset 46. This time, an instruction will be found.

!!!! How is computed the bytecode offset?

Each instruction has a bytecode index. This bytecode index is the delta between the bytecode offset of the first instruction in a compiled code and the instruction requesting its bytecode offset.

The bytecode offset is computed by adding the index to the initial PC minus one (why - 1?).

[[[
IRInstruction>>bytecodeOffset
	| startpc |
	startpc := self method compiledMethod initialPC.
	self bytecodeIndex ifNil: [^startpc].
	^self bytecodeIndex + startpc - 1.
]]]



!!! Overview of an IR method's structure

To give a general view of an IR method's structure, let us take a sample method that does nothing special.

[[[
sampleMethod
	| i |
	i := 5.
	[ i=0 ] whileFalse: [ i := i - 1 ].
]]]
	
In Figure *@fig5*, we see a list of 4 IR sequences on the far left of the picture. This is the start sequence of the sampleMethod IR (i.e., an IRMethod).

If we select the first sequence (A), we see the corresponding IRSequence instance: it has a number that is an integer representing its order in the sequence, and a sequence of IR instructions (B).

These instructions corresponds to the first statement the sampleMethod, plus an additional goto: instruction.

+The first sequence of instructions of the sampleMethod IR.>file://figures/IRMethod-structure-overview-1.png|width=60|label=fig5+



Let us explore these instructions. Figure *@fig6* (A) shows the first IR instruction (pushLiteral: 5). We see its source node, that is the assignment in the code of sampleMethod, and its bytecode index used to compute the bytecode offset of the instruction.

Figure *@fig6* (B) shows the goto: 2 instruction. This is a jump to the second sequence of the IRMethod instance, that we see in (C). These instructions represent the conditional in the while block of the second statement of sampleMethod.

The jump instruction is interesting, as it shows a conditional instruction that will jump either to the sequence of instructions that represents the body of the loop (the third sequence) or to the sequence of instructions which represents the next statement (the fourth sequence).



+Navigating the IR instructions sequences of the sampleMethod IR.>file://figures/IRMethod-structure-overview-2.png|width=60|label=fig6+

The following table shows the actual mapping between the bytecode offsets, the IRs and the nodes.

Why is goto:2 offset 41?

[[[
41  ->  pushLiteral: 5    ->  RBLiteralValueNode(5)
42  ->  popIntoTemp: #i   ->  RBAssignmentNode(i := 5)
41  ->  goto: 2	          ->  RBMessageNode([ i = 0 ] whileFalse: [ i := i - 1 ])
43  ->  pushTemp: #i      ->  RBTemporaryNode(i)
44  ->  pushLiteral: 0    ->  RBLiteralValueNode(0)
45  ->  send: #=          ->  RBMessageNode(i = 0)
46  ->  if: true goto: 4
                 else: 3  ->  RBMessageNode([ i = 0 ] whileFalse: [ i := i - 1 ])
48  ->  pushTemp: #i      ->  RBTemporaryNode(i)
49  ->  pushLiteral: 1    ->  RBLiteralValueNode(1)
50  ->  send: #-          ->  RBMessageNode(i - 1)
51  ->  popIntoTemp: #i   ->  RBAssignmentNode(i := i - 1)
52  ->  goto: 2           ->  RBMessageNode([ i = 0 ] whileFalse: [ i := i - 1 ])
54  ->  returnReceiver    ->  helperMethod12  | i |
                                              i := 5.
                                              [ i = 0 ] whileFalse: [ i := i - 1 ]
]]]



