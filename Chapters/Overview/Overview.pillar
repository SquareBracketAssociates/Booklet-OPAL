
!! Opal overview

!!! Roadmap (this subsection will be removed)
''Big picture:'' mention everything => content overview of the rest of the document (small section about each other chap.).
Give an overview of source code to bytecode compilation process.

''Jorge said:'' I think that the first thing that we need is a description of the Opal model, with the different classes that take part in it. Then we can explain how the compilation and decompilation work. And also explain the intermediate representation. Finally, how to extend and change the compilation process.

!!! Overview
+Opal complete compilation process.>file://figures/fullProcess.pdf|width=60|label=opalprocess+

Opal is the bytecode compiler for Pharo.

Opal is a flexible, configurable and adaptable.
The Opal compilation process, is built around 3 steps, from source code to the bytecode (see Figure *@opalprocess*):
- Source code to abstract annotated syntax tree (see Fig. *@sourcetoannotated*),
- Abstract syntax tree to intermediary representation,
- Intermediary representation to bytecode.

This bytecode is transformed on the fly by the virtual machine in assembly. This last step is not
the scope of OPAL.

!!! From Source to Annotated AST
We explain the process described by Fig. *@sourcetoannotated*.

+From source to annotated AST.>file://figures/SourceToAnnotatedAST.pdf|width=60|label=sourcetoannotated+

!!!! AST
An Abstract Syntax Tree (AST) is a tree representation of the source code. The AST is easy to manipulate and scan it.

The ASTs used by Opal come from refactoring engine. It uses ==RBParser== to generate ASTs, this step verifies the syntax. The structure of an AST is a simple tree.


!!!! Parsing an Expression
Using the message ==parseExpression:==, we get an AST representing an expression (i.e., it means that you can only parse expressions and not methods which are not expression).
Evaluate and inspect the following expression (See Figure *@SimpleAtomicExpression*).

[[[
t := RBParser parseExpression: '1 + 2'.
]]]

+Generated tree for =='1 \+ 2'==.>file://figures/SimpleAtomicExpression.pdf|width=60|label=SimpleAtomicExpression+


Let's try another example as shown in Figure *@SimpleAtomicExpressionP*, inspect the following expression:
[[[
RBParser parseExpression: 'one plus: two'.
]]]


+Generated tree for =='one plus: two'==.>file://figures/SimpleAtomicExpressionP.pdf|width=60|label=SimpleAtomicExpressionP+

Let's try a more complex example as shown in Figure *@SimpleMultiExpression*, inspect the following expression:
[[[
RBParser parseExpression: 'one plus: two plus: three'.
]]]

+Generated tree for =='one plus: two plus: three'==.>file://figures/SimpleMultiExpression.pdf|width=60|label=SimpleMultiExpression+


!!!! Parsing a Method

You can also parse a the code of a method using the message ==parseMethod:== instead of ==parseExpression:==. We will get a ==methodNode== object.
The following code snippet produces a methodnode whose selector is ==xPlusY== and the method body is a sequence of node containing statements. The first element is a ==messageNode== with a receiver, a message selector and arguments.

[[[
RBParser parseMethod: 'xPlusY x + y'.
]]]

+Generated tree for =='Generated tree for  'xPlusY x \+ y''==.>file://figures/ASTbeforeSemanticAnalysis.pdf|width=60|label=ASTbeforeSemanticAnalysis+


!!! Annotating an Abstract Syntax Tree

Once parsed we can perform a semantic analysis of the AST. The goal of a semantic analysis is to add semantic data to the generated tree. One of the key function of the semantic analysis is to bind variables.

Because as we saw before the AST only checks the ''syntax'' of the code. A semantic analysis  checks the semantics of the code: within the context of a class we can check whether the code is valid. We can identify if a variable is undeclared or used out of scope.

The AST is annotated by visiting the graph with two visitors:

- ==OCASTSemanticAnalyzer== performs the variable binding.
- ==OCASTClosureAnalyzer== performs the closure analysis

TODO: explains what is variable binding.
TODO: what is closure analysis.

!!!! Example

Let's check with an example.

[[[
| ast |
ast := RBParser parseExpression: '1 + 2'.

"visit and annotated the AST for the closure analysis "
OCASTClosureAnalyzer new visitNode: ast.

"visit and annotated the AST for the var binding"
OCASTSemanticAnalyzer new
		scope: Object parseScope;
		visitNode: ast.
]]]

TODO: What do we get!!!!

All the data of binding is injected in the AST, when you inspect your AST you can see the value properties is now
set to a dictionary.
TODO: WHERE!!!!

!!! Intermediate Representation

TODO: Please rewrite all that

Once we obtain an AST annotated with semantic data, we can translate it into an intermediary representation (IR). The intermediary representation is a abstraction over bytecode structured in tree. The advantages of IR over bytecode is that it is higher-level. In addition, with IR we can plug different bytecode sets in the compilation process.

We could think about generating bytecode from a Pharo subset to LegoOS. In addition IR is easier to manipulate than bytecode itself. Usually the bytecode optimization will be realized after this step.

In many case you will not manipulate IR.  You want to change jump, closure or push of the temp. It is a this level, if you want to indirect all the instance var access.  It's at the level of the AST. we should simply rewrite this part, the IR is for :
- 1 different bytecode plug,
- 2 Bytecode optimization (easier to manipulate,more accurate, and it's more coherent),
- 3 small grain manipulation.


+AST Annotated to Intermediary Representation.>file://figures/AnnotatedASTToIR.pdf|width=60|label=AnnotatedASTToIR+


A Visitor walks an AST and builds its corresponding IR tree. ==ASTTranslator==  visits each node and for each node  builds the corresponding IR node sequence. It uses the ==IRBuilder== for this task.
The ==IRBuilder== offers all the infrastructure to add each possible node.

!!! Bytecode
Once we have an IR tree, we will transform the IR tree in a bytecode sequence. We apply a new visitor but on the IR tree this time. Since IR is close to bytecode, the visitors visits each node and pushes the corresponding bytecode.

+Intermediary Representation to Bytecode.>file://figures/IRToBytecode.pdf|width=60|label=IRToBytecode+

TODO: EXPLAIN BETTER we need a code snippet

${inputFile:path=Compilation.pillar}$
